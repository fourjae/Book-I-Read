## 프로그래밍 심리학

### 2023-05-28 P.0 ~ P.48 - 옮긴이의 글, 서문, 1부 1장

### 2023-05-29 P.49 ~ P.102 - 1부 2장 ~ 1부 3장

### 2023-05-30 P.104 ~ P.139 - 2부 4장

### 2023-05-31 P.140 ~ P.172 - 2부 5장

### 2023-06-02
<details>
<summary>P.172 ~ P.202 - 2부 5장 ~ 2부 6장</summary>

```
**팀의 위기**
프로그래밍의 가장 중요한 작업단위는 “팀”이다.

팀 전체의 능력이 팀원 각자의 능력을 단순히 합한 것과 같지는 않다.
그렇기에 팀원을 잃더라도 업무를 서로 공유하고 의사소통함으로써 구멍을 메꿈으로써 팀의 능력을 유지한다.

사람들과 어울리지 못하는 구성원이 너무 똑똑하고 재능이 있을 경우 반사회적 행동을 할 가능성이 있다. 

집단 행동에 관한 사회심리학 연구 결과를 통해 프로그래밍 팀의 업무가 어려울수록 팀은 가장 효과적으로 팀을 이끄는 리더십이 있는 리더를 따르려고 한다.

우리의 업무는... 컴퓨터가 평가한다. 프로그램이 작동하지 않으면 누구의 탓인지 생각해보자.

작업을 공유하는 팀의 구성에서 개인의 기술보다는 성격이 더 크게 작용한다.

**변화를 통한 안정**
관리자는 프로그래밍 프로젝트에서도 대규모 조직의 특성이 수명보다 오래 존속한다는 것을 알아야 한다.

그 이유로 프로그래밍 팀도 최초 구성원들은 모두 떠났음에도 팀이 유지되는 경우가 있다. 팀의 목표와 성취가 새로운 구성원에게 전달되고 이를 유지하기 때문이다. 이는 마치 물은 계속 바뀌지만 강은 그대로라는 점과 흡사하다.

그러나 관리자는 잘하는 프로그래머가 기둥이라 생각하고 그 하나가 없어지면 무너진다고 생각한다.

“절대 없어서는 안 될 프로그래머가 있다면, 한시라도 빨리 그를 프로젝트에서 제거하라.” 관리자가 명심해야할 격언이라고 한다. 
1. 관리자가 그 핵심 인력을 신뢰하기 때문에 다른 프로그래머를 배치하지 않는다.
2. 그 핵심 인력이 붕괴 되면 그 인력을 통해 육성하는 초보 프로그래머도 없고 적응되어 있던 다른 인력도 없기 때문에 프로젝트가 진행되지 않는다. 진행 되어도 엉터리가 되고 폐기될 수 있다.
3. 만약 핵심 인력을 덜 신뢰했다면 경험 있는 프로그래머를 한 명이라도 더 배치함으로써 핵심 인력에 대한 의존도를 낮추고 프로젝트를 진행할 수 있었을 것이다.
```
  
</details>

### 2023-06-04
<details>
<summary>P.202 ~ P.231 2부 6장</summary>

```
**성과의 측정**
다음달에 제출해야할 보고서에 대한 압박(최종 제출일보다 계속 앞 당겨서 제출해야 할 때의 상황)이 클 수록 현재의 진척도가 아닌 다음 달에 대한 예상으로 채워진다.

보고서 여과 단계(이번 달에 많은 진척도가 있었으므로 진척도를 낮게 수정, 다음 달에 운이 나빠지면 이번 달 나머지 진척도와 함께 다음 달 진척도를 합침으로써 진척도 임의로 수정 혹은 내용을 부풀리거나 문제를 두 개로 나누는 등)를 통해 하위 보고서 부터 보고서를 통합하며 거치다 보면 최상부에는 엉뚱한 내용이 올라가곤 한다.

진척도 측정 자체보다 보고서에 대한 보여주기식 강조가 심할 경우 팀 리더들은 보고서의 정확도를 높이는 것보다 그럴듯한 숫자로 대충 채우고 제출 하는 것이 여러 사람의 시간을 아낄 수 있는 것을 알게됨으로써, 보고서와 실제 진행 상황 사이의 관련성이 매우 작아진다.

인지부조화 상태, 사회적 압력은 프로그래밍에서도 일어난다.
예를 들면, 6명의 참가자중 5명은 가짜를 이야기 하면 1명 또한 진짜를 이야기 하지 못하고 가짜를 이야기 하는 것이다.
그러나, 내 편이 한 명이라도 존재하면 그대로 진짜를 이야기할 용기를 얻는다.
이러한 문제를 해결하기 위해 회의에서 데블스 에드버킷(devil's advocate)을 활용하기도 한다.

**프로젝트의 구조**
프로젝트에는 여러(개발,테스트,평가, 그 외 특수 업무)그룹을 통해 프로젝트가 진행되나 우발적인 사건을 예측할 수 없으므로 조직 개편을 여러 번 겪게 된다.

그러나 개편을 통해 다른 팀원이 들어와 새로운 팀의 목표에 대한 일부가 자신의 목표와 일치하지 않을 경우 혹은 관리자가 의도적으로 분리를 유발할 경우 사회적 문제가 발생하거나 팀끼리 상호 혐오가 일어나곤 한다.

실무자의 지위는 기술적인 업무 수행 능력에 나뉜다.
관리자에게 보여주기식 일하는 실무자는 기술적인 우월성 대신 지위 및 급료가 올라가곤 한다.(프로젝트를 잘 하고 있다는 인상을 줄 수 있기 때문이다.)

모든 편견에는 대가가 따른다. 사람과 성별에 대한 차별, 팀에 대한 편견 등 이는 프로그래밍, 관리 측면에서 인적 자원이 부족한 이유가 될 수 있다.
```

</details>



### 2023-06-05
<details>
<summary>P.234 ~ P.268 3부 7장</summary>

```
**프로와 아마추어**
--아마추어는 대학생, 취준생을 의미하는 것 같으며 프로는 직장인으로 해석된다.--

아마추어는 자신이 사용할 프로그램을 만들고 프로는 남이 사용할 경우를 대비할 프로그램도 만든다.

아마추어는 스스로 정한 목적을 달성할 프로그램을 만들어내며 어려운 부분을 극복하는 문제를 가지면 된다. 그리고 문제를 해결하는 방법을 배운다.

프로는 눈 앞의 문제를 우회하고 개발할 수 있다. 그러나 나중에 또 직면했을 때 해결하기 위해 이 부분을 이해할 수 있어야 한다. 그리고 직업(프로그래밍)에 대해 배운다.

**일에 대한 차이**
프로는 프로그램을 개발할 때에는 그 용도에 맞게 적절한 수준으로 작업해야 한다. 적절한 수준 이상으로 작업하면 낭비일 뿐이다. 아마추어는 이를 이해하지 못한다.

-> 풀어야할 문제를 알아야 한다. 그 프로그램의 용도에 맞게 고려해야 한다. 
- 책에서는 아마추어가 행렬을 만들 때, 좋은 배울 기회를 얻었다 생각하여 A의 기술을 고집했지만 프로는 A가 왜 필요한지 이에 대해 반문하고 A에 대한 불필요성을 설명해주었다. 

- 마치 데이터 쌓이는 속도가 느리지만 동시성 처리와 예외들을 구현해야 하고, 아키텍처는 그 프로그램의 구조에 따라 정답이 없지만 가장 최신 아키텍처를 고집하는 느낌인 것 같다.
이렇게 되면 프로그램 자체보다 기술에 대한 의미가 큰 것 같다는 의미??


빨리 완성하는 것이 목표인 그룹은 현재 수단이 동작하지 않으면 버리고 다른 수단을 찾는다. 
효율성을 추구하는 그룹은 어려움이 생겨도 접근 방법을 바꾸지 않고 끝까지 문제를 파헤쳐 포기해야 할 때까지 접근한다.
관리자는 이에 따라 프로젝트 목표를 수립할 수 있어야 한다.

**프로그래밍 작업 단계**
프로그래밍을 심리학적인 관점에서 연구하려면 복잡한 행위들을 간단한 단위로 분해해야 한다. 지금은 각 범주(문제 정의, 분석, 흐름도 작성, 코딩, 테스트, 문서화 등)의 경계가 모호하고 잘 구별되지 않기 때문.

그러나 실제로 간단한 단위로 나눌 수 있다 하더라도 바람직 하지 않다. 다양한 요인들에 의해 해야 할 일이 바뀔 수 있고 업무마다 필요한 재능과 프로그래머들은 각자 다양한 종류의 재능을 갖고 있기 때문이다.

그렇기에 이상적인 프로그래머는 장애물을 만나면 다른 작업으로 전환함으로써 다른 작업을 통해 현재 작업을 해결하려고 노력한다.
-> 문제 정의에서 디버깅을 할 수 있다. 그렇기에 유동적인 작업이 필요하다.

버그를 찾는 사람에게는 분석적인 사고력이, 수정하는 사람에게는 종합적인 사고력이 필요하다. 둘 다 뛰어날 수는 있지만, 둘 다 뛰어난 사람을 찾는 것보다 두 가지를 잘하는 팀을 찾는게 쉽다. 각 팀원들의 소질과 능력을 통해 팀의 능력이 발휘되니 말이다.
```

</details>

---

### 2023-06-06
<details>
<summary>P.269 ~ P.297 3부 8장</summary>

```
**두 프로그래머**
성격은 사람과 사람을 구별시켜주는 개인적 특성이며 그 사람의 정체성이다.

두 프로그래머의 성격이 프로그래밍 성과에 미치는 예시가 있다.
한 초보 프로그래머는 에러 발생시 시도해보고 고친다. 그리고 프로그래밍 교육을 통해 해결한다.
다른 전문가 프로그래머는 성격이 악질적이고 자기 자신에 프로그래밍에 대한 자신감이 있었다. 그래서 에러가 발생하여도 에러가 아니라는 태도만 보였으며, 누군가 그 프로그램에 대해 문제를 알려줘도 자신의 자부심 때문에 교육이나 다른 사람의 자부심을 받으려 하지 않았다.

**변하는 성격**
프로그래머의 성격이 바뀌는 원인을 밝히는 것은 어렵다. 육체적일수도, 정신적일수도, 외부적일 수도 있다. 남들은 알 수 없는 개인 사생활 때문에 업무에 지장을 받아 성격이나 성적이 바뀔 수 있기 때문이다.

문제의 원인을 밝혔을 때, 없앨 수는 없어도 적절한 조취로 완화는 가능하다. 이러한 징후들을 정보로 삼아 조치를 취하는 것이 좋다.

**프로그래밍에 필요한 성격**
성격을 측정하는 것은 어렵다. 프로그래밍에는 지능보다 성격이 더 중요하다.
-> 지능이 떨어지는 사람의 일화를 인용하는 사람은 없기 때문이다.

---
1.프로 프로그래머는 스트레스를 견딜 수 있는 능력이 있어야 한다.
-> 외부에서 업무와 일정을 통해 자신의 경력이 결정될 수 있기 때문

2.잦은 변화에 잘 적응할 수 있어야 한다.
-> 업무가 다양하기 때문이며 외부요인에 의해 작업이 중단되기도 하기 때문

3.겸손해야 한다.
-> 자신만만한 사람은 위험하다. 그러나 두 성격 모두 배치 시스템, 온라인 시스템 등 적합한 곳이 있을 것이라고 추측한다.

4.유머감각이 필요하다.
-> 컴퓨터는 자신을 바보로 만드는 기계이기 때문에 멍청한 실수를 자주 보기 때문

5.융통성이 있어야 한다.
-> 컴퓨터가 융통성이 떨어지기 때문
---

성격검사는 꼭 필요하다. 그러나 피검사자가 속임수를 쓸 수 있다. 그렇기에 원하는 답변을 만들어내는 지능검사가 될 수 있다. 그러나 "검사자를 속일 수 있는 성격" 또한 필요하기 때문에 프로그래머에게 필요한 성격을 갖춘 사람이 될 수 있다.

성격검사는 완벽하지 않지만 성격 요소를 추려 낼 수 있다. 결국 성격이라는 주제를 끊임없이 연구하면 프로그래머의 능률도 올라가게 될 것이다.
```

</details>

### 2023-06-07
<details>
<summary>P.299 ~ P.328 3부 9장</summary>

```
**심리적 자세**
사람의 눈은 기대한 면만 보는 경향과 심리적 자세로 인해 자연어로 의미가 있는 단어, Symbol 등을 오인하고 오류가 발생할 수 있다. 컴파일러나 해석기를 믿고 있지만 이 또한 오류를 오류라고 판단하지 못하는 상황이 분명히 존재한다.
:)
1. 자연어에 의미가 있다면 프로그램에 의미가 있다고 보게 된다.
2. 'FIVE' 라는 Symbol의 값이 4로 설정되어 있다면 누가 믿겠는가?
3. 동음이의어 사용시 상황이 더 나빠진다.
4. 축약어 사용시 의미에 대한 해석 달라질 수 있다.

오류가 있는 코드를 해결할 때 주석문은 심리적 자세에 독이 될 수 있다.

**문제 해결에 대하여**
프로그래밍의 객관적인 척도는 부족하기 때문에 열심히 일하느냐를 기준으로 삼곤 한다.
- 한 프로그래머가 14시간씩 주 6일 총 8주간 프로그램을 만들어 승진하기도 하지만
- 이를 본 다른 프로그래머가 처음부터 다시 만들고 디버깅 완료까지 초과근무 없이 1주일만에 끝이 났다. + 속도 8배 상승, 용량 절반, 코드 줄 까지 절반으로 줄었다.

문제의 일부 요소를 해결할 때 깊이 생각하지도 않고 중요하지 않다고 여기고 간과할 경우 문제 해결을 어렵게 만든다.

지능은 통계적인 개념이다. 어떠한 문제를 해결한다고 지능을 측정할 수 없다.
높은 지능이 잘못된 답을 내거나 낮은 지능이 옳은 답을 내는 경우도 많기 때문이다.

**프로그래밍을 위한 지능의 여러 측면**
사람들은 각자 고유의 문제 해결 기법을 갖고 있다. 서로 잘하는 것이 다르고 능력이 다르기 때문이다. 그 예시는 밑과 같다.

- 기억력이 좋은 사람은 그 코드에 대한 흐름을 기억을 해내서 다음날 문제를 해결하기도 하고
- 기억력이 없었다면 프로그램에 대한 테스트 코드를 바로 만들어서 오류를 발견하는 방법을 취할 수도 있다.

문제를 해결할 때는 자신의 능력을 최대한 활용하여 그에 맞는 방법을 선택하는것이 최상이다.

프로그램을 설계할 때는 창의력, 아이디어를 생각하고 이를 설명하는 능력이 필요하지만
코딩 단계에서는 숲 보다 나무 가꾸는 능력이 필요하다.

**적성 검사**
프로그래머에게 적성 검사는 적절하지 않다.

1.프로그래밍 업무는 다양하다. 그런만큼 그 사람의 능력에 대해 측정되지 않은 영역이 있을 수 있다.

2.제한시간을 두고 풀어야 하는 시험과 달리 프로그래밍은 경주가 아니다. 장기 기억력보다 단기 기억력을 강조한다. 학교 성적에서 측정되는 부분과 달리 프로그래머가 정작 관심 있는 부분은 측정되지 않는다.

3.대학입학시험을 위한 고액 과외를 잘 받은 학생들이 프로그래머 유망주를 선발해주는 지팡이가 되지는 못한다.

4.PAT(Programmer's Aptitude Test)이라는 검사가 사용 되었지만 해당 검사도 결국 꾸준히 검사하면 성적을 의도적으로 높일 수 있으며, 관리자가 점수를 매긴다 해도 이는 프로그래머의 성과를 측정하거나 하나의 수치로 표현할 수 없다.

5.프로그래밍에는 단순 적성보다 중요한 요소들이 있고 검사 구조를 살펴보면 무엇이 문제인지 알 수 있다.

6.PAT 검사(기하도형 관계 규칙, 산술 추론, 수열)의 예시로 
-> 1,4,7 다음에 나올 숫자가 10이라고 쓰는게 프로그래머에게 요구되는 능력일까?
-> 오히려 10000, 20000, 30000 숫자 다음에 왜 7232가 나오는지 일상적이지 않은 패턴을 찾아내는 능력이 필요하다.
(15bit Register에 저장될 경우 2^15(32767)의 숫자를 부호 없이 표현할 수 있다.)

그러나 많은 회사들은 경력 프로그래머를 뽑을 때에도 PAT 이외의 다른 방법이 없기 때문에 당장 사용할 수 있는 방법을 사용하고 있다.

- 지능보다는 성격이나 업무 습관, 훈련이 더 필요할 것이며 지능과 다르게 삶의 경험을 통해 바뀔 수 있다. 즉 어떤 프로그래머를 양성할 것인가로 말할 수 있으며 좋은 프로그래머를 생산하는 훈련 과정에 관심을 가져야 한다.
```

</details>


### 2023-06-08
<details>
<summary>P.329 ~ P.359 3부 10장</summary>

```
**동기 부여**
인간은 동기라는 원동력이 존재한다.
프로그래머에게 동기 부여는 중요하다. 그러나 동기를 더 부여해야할 수도 줄여야 할 수도 있다.

동기부여는 특정 환경에 따라 달라진다.
프로젝트 초기와 끝, 저축과 급료 빚의 유무 등에 따른 중요성 등
돈도 중요하지만 더 나은 방식(업무와 관련한 보상과 욕구)으로 효율적인 동기부여를 해주어야 한다.

**프로그래밍에 대한 훈련과 수업, 교육**
프로그래밍을 교육하는 방식에서 수업과 교육, 훈련은 엄연히 다르다.

사소한 내용을 배우는데 실패하면 배움에 있어 더 나아갈 수 없다.
교육은 일반적인 원칙과 기술 습득이고
훈련은 특수한 기술에 대한 습득이다.

훈련을 선행해야 교육이 가능하다. 훈련이 되지 않으면 교육을 하여도 기술이 별로 늘지 않고
개념을 배우는 데도 진전이 없다.

**학습을 저해하는 요인들**
기술을 처음 배울 때 적용했던 상황을 다른 상황에서도 쉽게 적용할 수 있는가?
이는 지식의 목록에 하나 추가되는 것 이상의 효과가 있다.

일정 규모의 문제들을 해결해도 그 이상을 해결하지 못하는 프로그래머들이 많다.
그러나 그 반대도 많다. 일반적이고 강력한 기술 적용으로 필요 이상의 오버헤드가 발생하기도 하기 때문

새로운 것에 대한 두려움, 실패에 대한 걱정, 자신의 약점을 인정하지 않는 마음
모두 학습에 악영향을 미친다.

예:) 10개로 구성된 목록의 규모 프로그램에서 검색할 때는 이진 검색 알고리즘보단 순차 탐색이 더 효율적이다.

**프로그래밍을 학습하는 방법**
스스로 발전하기 위해 경험한 것을 배움으로 발전시키기 위해서는 학습하는 방법을 배워야 한다.
자신이 무엇을 알고 무엇을 모르는지 배우고 학습 방식의 성향에 따라 배우는 방법이 다르다.

개인별 학습 성향과 정보, 틀린 답에 포함된 추가 정보를 활용 등 
모든 정보를 사용해서 능동적으로 프로그래밍을 공부해야 한다.

프로그램이 정확하게 동작하지 않으면, 더 많은 것을 배울 기회가 생긴다.
그러나, 현실적으로는 일정이 지연되고 결과를 내는게 급선무일 때가 많다.

위와같은 모순적인 상황에서 프로그래머는 새로운 기술을 적용해보고 되지 않으면
기존의 기술로 마무리 한다. 이 후 나중에라도 시도할 수 있도록 TC를 만들어 놓자.

프로그램을 만들기 위해 언어의 지식을 갖추어야 하고 능숙하지 않으면 문제를 해결하기 보다 
언어 공부가 우선이기 때문에 포기하기도 한다.

그렇기에 정규 교육과정은 어떤 도구를 학습으로 활용할 수 있을 정도로는 훈련을 시켜야 한다.

```

</details>

### 2023-06-09
<details>
<summary>P.360 ~ P.392 4부 11장</summary>

```
**프로그래밍 언어와 도구**
프로그래밍 언어와 언어의 다른점은 무엇일까?

1. 프로그래밍 언어에는 말하기 형태가 존재하지 않는다.
2. 입을 통해 한 말은 사라지지만 프로그래밍 언어는 사라지지 않는다.
3. 내뱉는 말은 다방향 송신, 일방향 수신이 가능하지만
   프로그래밍은 한 방향 송신 한방향 수신이다.
4. 사람과 사람은 같은 언어로 대화하지만, 프로그래밍 언어는 입력을 해도 컴퓨터가 알아듣는 언어는 다르다.(기계어 등)

그 외에도 감정 표현, 명령, 선언, 메타언어, 시적 표현, 사교적 기능 등의 차이가 존재한다.

**프로그래밍 언어 설계**
프로그래밍 언어의 표준은 계속 변한다. 이 사실을 반드시 고려해야 한다.

프로그래머는처음 배우는 언어가 아닌 익숙한 언어를 사용할 때 이를 버리고 낯선 언어를 사용하려는 고난을 선택하기 쉽지 않다.

그렇기에 작위적인 언어보다 여러 측면을 폭넓게 보여줄 수 있는 언어를 가르치는게 좋다.
프로그램을 최대한 빨리 작성하기 위한 목적으로 언어를 가르치면 성장의 한계를 만나게 될 가능성이 크다.

프로그래밍 할 때는 받을 수 있는 모든 도움 등을 받을 수 있도록 종합적으로 고려해야만 한다.
이를 통해 교육적인 효과를 더욱 크게 만들 수 있다.

그렇기에 프로그래밍을 잘하기 위해 우리는 생각하는 방식을 바꾸고 있을지도 모른다.
```

</details>


### 2023-06-11
<details>
<summary>P.393 ~ 427 4부 12 장</summary>

```
***프로그래밍 언어 설계에 대한 원칙***
**일관성**
정보의 내용을 기억하기 위해선 일관성의 원칙을 알아야 한다.
랜덤한 2진수 값 6개 외우는 것보단 1만개가 되어도 순서대로 이루어진 2진수를 순서대로 외우는게 쉽다.

일관성의 원칙 
- "동일한 표현은 그 위치와 상관없이 동일하게 동작한다."
- "문법적으로 동일한 구문은 문맥이 달라도 동일한 의미를 지녀야 한다."
이 원칙에서 멀어지면 오류를 범할 가능성이 커진다.

프로그래머라면 일관성을 유지하자
(변수 이름을 키워드로 사용하거나, 들여쓰기 등을 마음대로 하는 등, 변수의 크기를 다르게 선언 등을
통해 프로그래머의 잘못을 알게 될 수 있다.)

**간결성**
주석을 통해 읽기가 더 어려워지는 경향이 있다.
프로그래머의 정보 처리 능력을 통해 똑같은 프로그램도 길이를 다르게 볼 수 있다.
의미덩이를 잘라서 변환해서 볼 수 있는 능력이 있기 때문이다.

적절한 압축(SUM 함수 등을 사용), 데이터 구조화(명령 여러개를 줄여 하나의 명령으로 대체)를 통해 연산의 차원을 높이고 중복 정보 제거, 프로그램의 복잡도를 줄인다.

**근접성과 순차성**
잘 설계된 프로그래밍 언어는 공감각적 기억력과 순차적 기억력을 도울 수 있으며
프로그래머의 좋은 기억력을 도와 쉽게 찾을 수 있게 한다.

순차적으로 배열하는 것이 분기나 반복보다 더 다루기 쉽기 때문에
GOTO , 분기문 등의 프로그램은 이해하거나 디버깅하기 어렵다.
(마치 여러 페이지를 반복적으로 찾아 나가는 것이다.)
```

</details>

### 2023-06-12
<details>
<summary>P.428 ~ 455 4부 12 장 ~ 13장</summary>

```
**각 목적에 따라 사용되는 언어들**
특수 목적 언어로 사용되는 언어들은 그 외의 기능을 제공하지 않을 경우 시뮬레이션 할 수 없는 문제가 발생한다.

통계용 언어에는 복소수 연산 기능이 필요 없다.
문자열 처리 언어에는 복잡한 산술 연산이 필요 없다.
기계 제어 언어에는 산술보다 기하학 기능이 많을 것이다.
APL 프로그래머는 대용량 데이터를 처리할 때 APL의 한계를 느꼈을 것이다.

특수 목적의 언어는 사용하는 사람의 사고방식을 좌지우지하고
프로그램과 데이터를 조직화하는 방식을 언어가 결정한다.

실험을 통해 학생들이 제출한 프로그램을 읽어 보았는데 어느 프로그래밍 언어 출신인지 대부분 알 수 있었다.

어떤 프로그래밍 언어가 목적한 특수한 일을 잘 처리 할수록 사용자의 사고는 더 좁아진다. 이를 파헤치는 방법은 사고방식이 틀 안에 가둬지는 과정을 파헤치는 것이다.

특수 목적 언어는 해당 분야에 적합한 데이터 구조를 제공하고, 좀 더 간결한 프로그램이 가능하며
사용자의 기존 지식에 부합해야 성공할 가능성이 높다.

특수 목적 언어가 세상에 나타날 수록 프로그래밍 언어 설계 산업의 망신거리이다. 
머릿속으로만 생각해서 언어를 만들지 말고, 행동주의적 원칙에 입각하여 설계와 실험이 가능한 환경에서 언어를 개발하라.
그렇기에 프로그래밍 뿐만 아니라 설계에도 전문가가 되어야 한다.

**프로그램 테스트 도구**
하이픈 글자를 빼먹은 오류도 엄청난 재앙을 초래할 수 있다.
그것이 잘못의 크기와 그로 인해 발생하는 문제 사이에 연관관계가 없다는 뜻이며 프로그래밍의 본질이기 때문이다.

모든 오류의 제거가 가능한가? 불가능하다. 그러나 가능한 모든 수단을 동원해 프로그램을 테스트 해야 한다.

어떤 프로그램이 최대한 테스트 하기 쉬울까?
일관성, 근접성, 간결성이 뛰어난 프로그램일수록 테스트하기 쉽다.

그러나 이들은 측정하기가 어렵다. 참조 횟수, 참조 거리 등을 통해 관련된 연산들이
여기저기 퍼져 있는지 적은지 확인하고 프로그램 구조를 바꿈으로써 한 곳에 집중시킨다.

프로그래머가 테스트 분량을 미리 계획하여 정해진 분량을 테스트 할 수록 있도록 하고
관리자에게는 이전 테스트 결과와 다른 결과가 나타날 때만 통보하도록 개선해보자.

심리적인 측면에서 "근접성"을 논해보자.
어떤 프로그래머가 오류의 근원을 찾는 동안 잘못된 코드 영역을 살피고 있기 때문일 수 있다.
한 영역에만 집착하지 않도록 하고 다른 곳(프로그램 뿐만 아니라 주변 사물, 자연 등)으로 눈을 돌리게 하자.
```

</details>