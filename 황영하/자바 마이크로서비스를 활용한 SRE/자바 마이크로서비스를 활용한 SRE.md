### 2023-06-15
<details>
<summary>P.4 ~ P.46 CHAPTER 1 </summary>

```
마이크로서비스(MSA)는 소프트웨어 애플리케이션을 독립적으로 배포 가능하게 설계하는 특정한 방식이다.
MSA는 여러 컴포넌트로 분리되어 각기 다른 팀들이 독립적으로 개발하고 배포한다.
특히, 자신의 고객에게 필요한 비즈니스 요건에 대응한다.

MSA는 플랫폼 엔지니어링 문화를 가져야 한다.

기술적(UI,BE,DESIGN,NETWORK)으로 격리된 조직 보다는 교차(U,B,D,N) 기능을 가진 팀으로 새로운 비즈니스 요구 사항을 빠르게 처리한다.

애플리케이션 인프라 모니터링은 서비스의 가용성을 측정하고 복잡하게 분산된 시스템의 문제를 디버깅할 수 있도록 돕는다.
메트릭, 메트릭 데이터, 레이턴시, 사용률, 포화도, 에러, JVM 메모리(전체 시간 대비 가비지 수집 시간 비율 측정을 통해 포화도 메트릭 획득) 등으로 가용성 신호를 측정한다.

*구글은 서비스의 신뢰성 저하를 얼마나 허용할지 에러 예산에 합의하고, 기준 시간 동안 측정 가능한 목표치가 초과하면 신뢰성이 확보될 때까지 기능 개발보다 시스템 안정성 확보에 주력한다.

*넷플릭스는 구글보다 덜 정형화된 방식(맥락과 가드레일 스타일)이 잘 맞았다. 그렇기에 어느 방식이 옳다 그르다 가릴 수 없으니 조직에 잘 맞는 형태를 찾는것이 필요하다.

디버깅 도구를 통해 로그나 추적 신호로 가용성을 측정할 때는 정확도와 비용 사이에서 타협점을 찾아야 한다. 어느 한 쪽을 완전히 최적화 할 수 없기 때문이다.

시스템은 완벽해질 수 없다. 그 점에서 시스템을 바라보라.
결과의 완벽함 보단 모니터링, 경보, 신속한 문제 처리를 효과적으로 대응하는 것이다.

서비스 회복의 역설(Service recovery paradox) 
서비스 장애를 경험한 사용자가 이전보다 더 서비스를 신뢰하게 되는 모순이 있다.
이 때문에 사용자는 완벽한 서비스보다 원활한 문제 해결을 선호하는 경향이 있다.

파이프라인을 개선하면 전달 프로세스가 기존 시스템에 장애를 일으킬 가능성을 줄일 수 있다.

테스트 커버리지 100%는 허상이다. 더 발전한 모니터링 시스템이 낫다.
-> 효과적인 모니터링 시스템은 고장, 서비스 중단, 그 외 생각하지 못한 문제들을 발견할 수 있다.
-> 테스트 계층을 중첩시킬수록 장애 발생률은 낮아지나, 장애를 완전히 근절하는 건 불가능하다.

전체 비즈니스 애플리케이션에 적용할 수 있을 정도로 얻은 지식들을 캡슐화 하라.

플랫폼 엔지니어링 팀에게 개발팀은 고객이 최우선이며 모든 프로세스는 '관문이 아닌 가드레일'이 되어야 한다.

---
프로덕션 환경과 동일한 환경은 존재하지 않는다. - https://spring.io/blog/2017/08/08/there-s-no-place-like-production-springone-platform-will-illuminate-the-path

사이드카를 이용한 트래픽 관리 패턴에 대해 생각해보자.

```

</details>

<details>
<summary>P.47 ~ P.72 CHAPTER 2 </summary>

```
**애플리케이션 메트릭**
분산시스템은 수많은 MSA로 구성된다.
블랙박스 vs 화이트박스 모니터링은 각각 장단점이 존재하다.
보통 화이트박스가 더 많은 정보를 볼 수 있다. 그러나 반드시 어느 한 쪽을 선택할 필요는 없다.

HTTP 메서드, 상태코드, URI , Method 등으로 차원형 메트릭으로 구성된 스키마를 만들어
모니터링 시스템에 전송한다.

와일드카드와 '태그들'을 통해 계층형 메트릭도 사용한다. 그러나 해당 메트릭은 취약하다.
또한 와일드카드는 상태를 정확히 나타낼 수 없다.

계층형 메트릭보단 차원형 메트릭을 추천한다.

마이크로미터에서 MeterRegistry는 애플리케이션 측정 결과를 수집하는 인터페이스다.
이를 통해 여러 모니터링 시스템에 메트릭을 게시할 수 있다.

모니터링 시스템은 가독성도 좋아야 한다. (2147483648 바이트보다 2GB가 낫다.)

의미 있는 집계 수치를 나타내는 모든 태그(애플리케이션, 서비스 리전, API ENDPOINT, http method, 응답 상태 코드) 등을 고유하게 조합하여 활용한다.

유용한 공통 태그들은 다음과 같다.
애플리케이션 이름, 클러스터, 서버 그룹명, 인스턴스 이름, 개발과 프로덕션 환경

---
마이크로미터 내장 메트릭 게이지 예시
jvm.threads.live : 현재 활성 스레드 개수, 데몬 스레드, 일반 스레드 포함
jvm.memory.used : 바이트 단위 메모리 사용량
db.table.size : 데이터베이스 테이블 총 로우 개수
jetty.requests.active : 현재 활성 요청 개수
process.uptime : RuntimeMXBean이 보고하는 JVM 가동 시간
Kafka.consumer.fetch.latency.avg : 그룹 싱크 평균 소요 시간. KAFKA 클라이언트가 계산 및 보고

jetty.async.requests : 비동기 요청 횟수
postgres.transactions : 트랜잭션 실행 횟수(커밋, 롤백 포함)
jvm.classes.loaded : JVM이 현재 로드한 클래스 개수
jvm.gc.memory.promoted : GC가 수행되고 OLD 세대의 메모리 풀이 증가한 횟수

셀 수 있는 것은 절대 게이지로 측정하지 않는다. (카운터 사용)
셀 수 없는 것은 게이지로 측정한다. ( 게이지 사용)



```

</details>