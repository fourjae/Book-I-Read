### 2023-06-17
<details>
<summary>P.12 ~ P.46 Chapter 1 ~2 </summary>

고객 : "처음에는 요구 사항을 빠르게 반영해주었는데 시간이 지날수록 간단한 요구 사항도 개발이 안되고 있다."

개발자 : "단순해 보여도 변경할 곳이 너무 많다. 어떤 기능에 문제가 생길지 모른다."

소프트웨어의 설계가 미숙하고 엉망일 때 발생하는 전형적인 증상이다.

---

**if-else문을 추가할 수록 코드는 지저분해진다.**

요구사항이 추가될 수록 단순히 복사-붙여넣기로 추가하면 되므로, 빠르게 구현할 수 있다.

그러나 코드가 커지다 보면 추가하거나 수정하기 어려워지고 오래걸리게 된다.

이것이 "초기 요구사항은 빠르게 개발되었는데 시간이 갈 수록 개발이 안된다." 상황이다.

---

**수정하기 좋은 코드를 가져야 한다.**

- 코드를 분리하자. 두 종류의 코드가 섞일 때보다 분리할 때 더 구분하기 쉽다.

- 하나의 애플리케이션에 여러개의 기능이 분산된 것보다는 구조를 복잡하게 잡고, 코드를 분리함으로써 코드가 간결해지는 것이 낫다.

- 추가사항이 발생하면 기존의 처리 코드가 영향을 받지 않는다.

객체지향 설계를 통해 소프트웨어를 쉽게 변경할 수 있는 유연함을 가져야 한다.

---

**절차지향**은 프로그램 규모가 커질수록 데이터 타입이 변경되거나, 다른 예기치 못한 값을 추가 해야 할 경우 프로시저를 모두 수정해야 하거나 오류를 발생하기도 한다.

프로그램 수정 -> 다른 곳 문제 발생 후 수정 -> 다시 다른 곳 문제 발생 후 수정의 악순환 발생 가능

**객체지향**은 프로시저를 하나의 객체로 묶어 각 객체는 자신만의 기능만 제공하게 한다.
객체 별로 데이터와 프로시저를 알맞게 설정해야 한다. 이를 통해 객체의 데이터를 변경하더라도
해당 객체만 수정하면 된다. 이는 "캡슐화" 장점을 갖는다.

---

객체는 어떤 데이터 타입 값으로 보관하는지 중요하지 않다.

객체는 그 행위가 어떻게 일어나는지 알 수 없다. 단지, 그 행위 기능을 제공한다는 것이 중요한다.

이를 인터페이스(객체가 제공하는 기능에 대한 명세서)와 클래스를 사용하여 제공한다.

```
이 인터페이스를 이용하여 클래스를 구현하고 클래스는 메모리에 객체(인스턴스) 생성
이 인스턴스는 인터페이스에 정의된 기능 제공
```

---

객체는 자신만의 책임과 크기가 있다.

파일 읽기, 암호화 처리, 파일 쓰기 객체들은 각각 자신의 기능만 수행하고 책임을 가져야 하며 다른 기능이 필요할 경우 해당 객체에 요청한다.

객체 지향 설계를 지닌 프로그램을 만들기 위해 객체에 대한 할당을 미리 결정해야 한다.

- 기왕이면 객체가 갖는 책임을 작게하고 객체가 제공하는 기능의 갯수가 적도록 구현한다.

- 여러개의 프로시저를 하나의 기능에 넣지말고(절차지향이 되버린다.) 한 객체는 하나의 책임을 갖게 함으로써, 객체가 갖는 책임을 분해한다. 이를 단일 책임 원칙(Single Responsibility Principle; SRP)이라고 한다.

---

**한 객체가 다른 객체의 메서드를 호출할 때 의존(Dependency)라고 한다.**

- 의존을 할 경우 해당 객체의 타입이 변경될 때 나도 변경될 가능성이 높다.

- 순환 의존이 발생할 수 있다. A -> B -> C -> A 순서대로 호출할 수 있기 때문이다.

- 이를 해결하기 위해 의존 역전 법칙(Dependency inversion principle; DIP)를 적용한다.

</details>